graph_list[[m]] <- as.undirected(net3)
# plot the graph of the month
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
#for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[1]]]
snap2 <- graph_list[[months[8]]]
par(mfrow = c(1, 1))
plot(
snap2,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
plot(
snap1,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
count <- 0
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){ # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[1, k+1] <- T_k[1, k+1] + 1 # increase the function
}
}
}
T_k
snap1 <- graph_list[[months[1]]]
snap2 <- graph_list[[months[9]]]
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
#for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[1]]]
snap2 <- graph_list[[months[9]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
count <- 0
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){ # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[1, k+1] <- T_k[1, k+1] + 1 # increase the function
}
}
}
T_k
ecount(snap1)
ecount(snap2)
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
#for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[1]]]
snap2 <- graph_list[[months[10]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
months[0]
months[1]
months[10]
months[9]
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
#for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[8]]]
snap2 <- graph_list[[months[9]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
count <- 0
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){ # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[1, k+1] <- T_k[1, k+1] + 1 # increase the function
}
}
}
T_k
ecount(snap1)
ecount(snap2)
pairs
T_k <- T_k / pairs
T_k[1,]
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[i]]]
snap2 <- graph_list[[months[i]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[1, k+1] <- T_k[1, k+1] + 1 # increase the function
}
}
}
}
T_k
for (i in 1:(length(months)-1)){
snap1 <- graph_list[[months[i]]]
snap2 <- graph_list[[months[i]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[i, k+1] <- T_k[i, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k <- matrix(0, nrow = 1, ncol = 6) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[i, k+1] <- T_k[i, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k[1,]
T_k <- matrix(0, nrow = length(months)-1, ncol = 6) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[i, k+1] <- T_k[i, k+1] + 1 # increase the function
}
}
}
}
T_k
pairs
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 6) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 6) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>5) # we group all the one with above 5 connection together
k <- 5
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- rowMeans(T_k, na.rm = TRUE)
t_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k<=4) # we group all the one with above 5 connection together
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k<=4){ # we group all the one with above 5 connection together
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- rowMeans(T_k, na.rm = TRUE)
t_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
k_values <- as.numeric(rownames(T_matrix))
k_values <- as.numeric(colnames(T_k))
plot(k_values, t_k)
k_values <- as.numeric(rownames(T_k))
plot(k_values, t_k)
length(k_values)
k_values
k_values <- numeric(5)
k_values
k_values <- c("0", "1", "2", "3", ">4")
k_values
plot(k_values, t_k)
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k)
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k)
plot(k_values, t_k)
library(ggplot2)
ggplot( aes(x = k_values, y = t_k)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "steelblue", size = 2) +
labs(title = "Triadic Closure per Grado k",
x = "Grado k",
y = "t(k) (media)") +
theme_minimal(base_size = 13)
plot(k_values, t_k_mean, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
k_values <- c("0", "1", "2", "3", ">4")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
T_k <- matrix(0, nrow = length(months)-1, ncol = 2) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(2) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>1) # we group all the one with above 5 connection together
k <- 1
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
k_values <- c("0", "1")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
