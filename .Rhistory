deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
net3 <- simplify(net3, remove.loops=T)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
triangles_over_time
opt
closure_prob_ot
# now we want to create the graph progressively by the time, the idea is, since the graph is quite sparse, to see how it evolve month by month
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net3 <- add_edges(net3, t(new_edges))
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
head(deg)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
net3 <- simplify(net3, remove.loops=T)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net3 <- add_edges(net3, t(new_edges))
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
deg
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
net3 <- simplify(net3, remove.loops=T)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
triangles_over_time
opt
closure_prob_ot
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net3 <- add_edges(net3, t(new_edges))
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
#net3 <- simplify(net3, remove.loops=T)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
triangles_over_time
opt
closure_prob_ot
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
for (i in 1:nrow(new_edges)){  # we add the edge only if it is not a loop (mention to itself), we do this because this type of connection are not useful for our research
if(new_edges[i,1] != new_edges[i,2])
net3 <- add_edges(net3, t(new_edges))
}
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
for (i in 1:nrow(new_edges)){  # we add the edge only if it is not a loop (mention to itself), we do this because this type of connection are not useful for our research
if(new_edges[i,1] != new_edges[i,2])
net3 <- add_edges(net3, c(new_edges[i,1], new_edges[i,2]))
}
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
for (i in 1:nrow(new_edges)){  # we add the edge only if it is not a loop(mention to itself), we do this because this type of connection are not useful for our research. and if it wasn't already in the graph, we are interested in the single connection, if there are more we can use it to distinguish strong and weak ties
if(new_edges[i,1] != new_edges[i,2] && !are.connected(net3, new_edges[i,1], new_edges[i,2]))
net3 <- add_edges(net3, c(new_edges[i,1], new_edges[i,2]))
}
}
# we first calculate the triangles
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# then the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
triangles_over_time
opt
closure_prob_ot
snap1 <- graph_list[[months[5]]]
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
layout2 <- layout_on_sphere(net3)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
closure_prob_ot <- c()
opt <- c()
graph_list <- list()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
# create the new edges
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
for (i in 1:nrow(new_edges)){  # we add the edge only if it is not a loop(mention to itself), we do this because this type of connection are not useful for our research. and if it wasn't already in the graph, we are interested in the single connection, if there are more we can use it to distinguish strong and weak ties
if(new_edges[i,1] != new_edges[i,2] && !are.connected(net3, new_edges[i,1], new_edges[i,2]))
net3 <- add_edges(net3, c(new_edges[i,1], new_edges[i,2]))
}
}
# calculate the triangles and probability of closure
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# calculate the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
# save the snapshot of the graphs
graph_list[[m]] <- net3
# plot the graph of the month
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
# create the new edges
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
for (i in 1:nrow(new_edges)){  # we add the edge only if it is not a loop(mention to itself), we do this because this type of connection are not useful for our research. and if it wasn't already in the graph, we are interested in the single connection, if there are more we can use it to distinguish strong and weak ties
if(new_edges[i,1] != new_edges[i,2] && !are.connected(net3, new_edges[i,1], new_edges[i,2]))
net3 <- add_edges(net3, c(new_edges[i,1], new_edges[i,2]))
}
}
# calculate the triangles and probability of closure
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
# calculate the number of open triangles -> we have 2 of the 3 edges already and we want to close it so add the remaining edge
deg <- degree(net3)
open_triangles <- sum(deg * (deg-1) / 2) # sum of possible combination for each vertex
if(open_triangles > 0)
closure_prob <- sum(count_triangles(net3)) / open_triangles # the number of closure triadic compared to the number of possible triadic
else
closure_prob <- 0
opt <- c(opt, open_triangles)
closure_prob_ot <- c(closure_prob_ot, closure_prob)
# save the snapshot of the graphs
graph_list[[m]] <- net3
# plot the graph of the month
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout2,
vertex.label=NA,
edge.arrow.size=.2,
vertex.size=deg/10+2
)
}
