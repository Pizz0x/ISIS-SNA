#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
net <- simplify(net, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=layout_with_fr(net),
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
net <- make_empty_graph(directed=F) # start from an empty graph
users <- unique(c(mentions$from, mentions$to))
df <- read.csv("tweets.csv") # import the data
head(df)
# for the initial graph we are interested in connection between people, so we will create a directed graph
# where an edge exit from a node in case of a mention or retweet to another member
# so we need to create edge that goes from a user to another if the second user is cited with @*username* by the first
usernames <- unique(df$username)
results <- list()
row_index <- 1
# get a list of pair: user that mention, user mentioned
for (i in 1:nrow(df)) {
from_user <- df$username[i]
tweet_text <- df$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
results[[row_index]] <- data.frame(from = from_user, to = to_user, stringsAsFactors = FALSE)
row_index <- row_index + 1
}
}
}
mentions <- do.call(rbind, results) # transform the list of dataframe in a dataframe
head(mentions)
users <- unique(c(mentions$from, mentions$to)) # list of users mentioned in the edges (we need it later)
# now we have our list of mentions, let's transform it into a weighted edge list:
mention_counts <- as.data.frame(table(mentions$from, mentions$to), stringsAsFactors = FALSE)
colnames(mention_counts) <- c("from", "to", "weight")
mention_counts <- mention_counts[mention_counts$weight > 0, ]
head(mention_counts)
net <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net <- simplify(net, remove.loops=T)
V(net)$size <- 5
l <- layout.fruchterman.reingold(net)
E(net)$width <- E(net)$weight/50
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
class(df$time) # we want a datatime value not character
df$time <- mdy_hm(df$time)
class(df$time)
sorted_df <- df[order(df$time),]
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net <- make_empty_graph(directed=F) # start from an empty graph
net <- add_vertices(net, length(users), name=users)
layout <- layout_with_fr(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
net <- simplify(net, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=layout,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net <- make_empty_graph(directed=F) # start from an empty graph
net <- add_vertices(net, length(users), name=users)
layout <- layout_with_fr(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
triangles <- sum(count_triangles(net))/3
triangles_over_time <- c(triangles_over_time, triangles)
net <- simplify(net, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=layout,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
par(mfrow = c(1, 1))
plot(as.Date(paste0(months, "-01")), triangles_over_time, type = "b", col = "blue",
xlab = "Mese", ylab = "Triangoli (Triadic Closure)", main = "Evoluzione del Triadic Closure")
plot(months, triangles_over_time, type = "b", col = "blue",
xlab = "Mese", ylab = "Triangoli (Triadic Closure)", main = "Evoluzione del Triadic Closure")
par(mfrow = c(1, 1))
plot(months, triangles_over_time, type = "b", col = "blue",
xlab = "Mese", ylab = "Triangoli (Triadic Closure)", main = "Evoluzione del Triadic Closure")
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net <- make_empty_graph(directed=F) # start from an empty graph
net <- add_vertices(net, length(users), name=users)
layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
triangles <- sum(count_triangles(net))/3
triangles_over_time <- c(triangles_over_time, triangles)
net <- simplify(net, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=layout,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
df <- read.csv("tweets.csv") # import the data
head(df)
# for the initial graph we are interested in connection between people, so we will create a directed graph
# where an edge exit from a node in case of a mention or retweet to another member
# so we need to create edge that goes from a user to another if the second user is cited with @*username* by the first
usernames <- unique(df$username)
results <- list()
row_index <- 1
# get a list of pair: user that mention, user mentioned
for (i in 1:nrow(df)) {
from_user <- df$username[i]
tweet_text <- df$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
results[[row_index]] <- data.frame(from = from_user, to = to_user, stringsAsFactors = FALSE)
row_index <- row_index + 1
}
}
}
mentions <- do.call(rbind, results) # transform the list of dataframe in a dataframe
head(mentions)
users <- unique(c(mentions$from, mentions$to)) # list of users mentioned in the edges (we need it later)
# now we have our list of mentions, let's transform it into a weighted edge list:
mention_counts <- as.data.frame(table(mentions$from, mentions$to), stringsAsFactors = FALSE)
colnames(mention_counts) <- c("from", "to", "weight")
mention_counts <- mention_counts[mention_counts$weight > 0, ]
head(mention_counts)
# now we have all we need to create our first graph
net <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net <- simplify(net, remove.loops=T)
V(net)$size <- 5
l <- layout.fruchterman.reingold(net)
E(net)$width <- E(net)$weight/50
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
# We can now get some information about the data:
net <- net - V(net)[degree(net, mode="all")==0]
l <- layout.fruchterman.reingold(net)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
# first we need to sort the data set based on the timestamp:
class(df$time) # we want a datatime value not character
df$time <- mdy_hm(df$time)
class(df$time)
sorted_df <- df[order(df$time),]
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net <- make_empty_graph(directed=F) # start from an empty graph
net <- add_vertices(net, length(users), name=users)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
triangles <- sum(count_triangles(net))/3
triangles_over_time <- c(triangles_over_time, triangles)
net <- simplify(net, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=l,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
net <- make_empty_graph(directed=F) # start from an empty graph
net <- add_vertices(net, length(users), name=users)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net <- add_edges(net, t(new_edges))
}
triangles <- sum(count_triangles(net))/3
triangles_over_time <- c(triangles_over_time, triangles)
net <- simplify(net,remove.multiple = TRUE, remove.loops=T)
plot(
net,
main=paste("Rete al mese:", m),
layout=l,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
df <- read.csv("tweets.csv") # import the data
head(df)
usernames <- unique(df$username)
results <- list()
row_index <- 1
# get a list of pair: user that mention, user mentioned
for (i in 1:nrow(df)) {
from_user <- df$username[i]
tweet_text <- df$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
results[[row_index]] <- data.frame(from = from_user, to = to_user, stringsAsFactors = FALSE)
row_index <- row_index + 1
}
}
}
mentions <- do.call(rbind, results) # transform the list of dataframe in a dataframe
head(mentions)
users <- unique(c(mentions$from, mentions$to)) # list of users mentioned in the edges (we need it later)
# now we have our list of mentions, let's transform it into a weighted edge list:
mention_counts <- as.data.frame(table(mentions$from, mentions$to), stringsAsFactors = FALSE)
colnames(mention_counts) <- c("from", "to", "weight")
mention_counts <- mention_counts[mention_counts$weight > 0, ]
head(mention_counts)
net1 <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net1 <- simplify(net, remove.loops=T)
V(net1)$size <- 5
l <- layout.fruchterman.reingold(net1)
E(net1)$width <- E(net)$weight/50
net1 <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net1 <- simplify(net, remove.loops=T)
V(net1)$size <- 5
l <- layout.fruchterman.reingold(net1)
E(net1)$width <- E(net1)$weight/50
net1 <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net1 <- simplify(net1, remove.loops=T)
V(net1)$size <- 5
l <- layout.fruchterman.reingold(net1)
E(net1)$width <- E(net1)$weight/50
plot(net1, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
net <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
net <- simplify(net, remove.loops=T)
V(net)$size <- 5
l <- layout.fruchterman.reingold(net)
E(net)$width <- E(net)$weight/50
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
deg <- degree(net, mode="in") # Node degree -> most mentioned nodes on the social
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA, vertex.size=deg/3+3)
hist(deg, breaks=1:vcount(net)-1, main="Histogram of Node Degree")
deg.dist <- degree_distribution(net, cumulative=T, mode="in")
plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange", xlab="Degree", ylab="Cumulative Frequency")
# we can see that most of the nodes are not mentioned, but can still mention other nodes, so let's also see the out-degree
deg <- degree(net, mode="out") # Node degree -> most active nodes on the social
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA, vertex.size=deg/3+3)
hist(deg, breaks=1:vcount(net)-1, main="Histogram of Node Degree")
net <- net - V(net)[degree(net, mode="all")==0]
l <- layout.fruchterman.reingold(net)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
net <- net - V(net)[degree(net, mode="all")==0]
layout <- layout.fruchterman.reingold(net)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout, vertex.label=NA) # in this way we also get a cleaner graph
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout_in_circle, vertex.label=NA)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout_randomly, vertex.label=NA)
net <- net - V(net)[degree(net, mode="all")==0]
layout <- layout.fruchterman.reingold(net)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout, vertex.label=NA) # in this way we also get a cleaner graph
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout_in_circle, vertex.label=NA)
plot(net, edge.arrow.size=.1, edge.curved=.1, layout=layout_randomly, vertex.label=NA)
net2 <- net - V(net)[degree(net, mode="all")==0]
layout <- layout.fruchterman.reingold(net2)
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=layout, vertex.label=NA) # in this way we also get a cleaner graph
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=layout_in_circle, vertex.label=NA)
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=layout_randomly, vertex.label=NA)
net <- graph_from_data_frame(d=mention_counts, vertices = usernames, directed=F)
eigenCent <- eigen_centrality(net2)$vector
# let's plot the score on the graph:
bins <- unique(quantile(eigenCent, seq(0,1,length.out=15)))
vals <- cut(eigenCent, bins, labels=FALSE, include.lowest=TRUE)
my_col = heat.colors(length(bins))
colorVals <- rev(my_col)[vals]
V(net2)$color <- colorVals
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=l, vertex.label=NA)
# so who are the more relevant user?
sort(eigenCent,decreasing=TRUE)[1:10]
eigenCent <- eigen_centrality(net2)$vector
# let's plot the score on the graph:
bins <- unique(quantile(eigenCent, seq(0,1,length.out=15)))
vals <- cut(eigenCent, bins, labels=FALSE, include.lowest=TRUE)
my_col = heat.colors(length(bins))
colorVals <- rev(my_col)[vals]
V(net2)$color <- colorVals
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=layout, vertex.label=NA)
# so who are the more relevant user?
sort(eigenCent,decreasing=TRUE)[1:10]
betweenCent <- betweenness(net2)
cor(betweenCent,eigenCent)
bins <- unique(quantile(betweenCent, seq(0,1,length.out=30)))
vals <- cut(betweenCent, bins, labels=FALSE, include.lowest=TRUE)
colorVals <- rev(heat.colors(length(bins)))[vals]
V(net2)$color <- colorVals
plot(net2, edge.arrow.size=.1, edge.curved=.1, layout=layout, vertex.label=NA)
# Which are the most useful users to the graph connection?
sort(betweenCent,decreasing=TRUE)[1:10]
w <- cluster_edge_betweenness(net2)
sort(table(w$membership))
# we have 5 significant communities with 9 or more nodes, let's remake the graph with different color for each community
V(net2)$color <- rep("white", length(w$membership))
keepTheseCommunities <- names(sizes(w))[sizes(w) > 4]
matchIndex <- match(w$membership, keepTheseCommunities) # like %in%
colorVals <- rainbow(10)[matchIndex[!is.na(matchIndex)]]
V(net2)$color[!is.na(matchIndex)] <- colorVals
plot.igraph(net2, vertex.label = NA,layout=layout, vertex.size=5)
class(df$time) # we want a datatime value not character
df$time <- mdy_hm(df$time)
class(df$time)
sorted_df <- df[order(df$time),]
# now we want to create the graph progressively by the time, the idea is, since the graph is quite sparse, to see how it evolve month by month
df$month <- format(df$time, "%Y-%m") # to do this we need a new column -> month
net3 <- make_empty_graph(directed=F) # start from an empty graph
net3 <- add_vertices(net3, length(users), name=users)
#layout <- layout_in_circle(net)
# and for each month, we add the edges for the monthly tweets, measure the number of triadic closure and update the graph
triangles_over_time <- c()
months <- sort(unique(df$month))
months <- months[-c(1,2,3,4,5,6,7,8)]
months
par(mfrow=c(3,3))
for (m in months){
df_month <- df[df$month == m, ]
# this part is the same as before to create the edges:
edges <- c()
for (i in 1:nrow(df_month)) {
from_user <- df_month$username[i]
tweet_text <- df_month$tweets[i]
mentions <- regmatches(tweet_text, gregexpr("@\\w+", tweet_text))[[1]] # get the string in the text that are composed by @*username*
if (length(mentions) > 0) {
for (mention in mentions) {
to_user <- sub("@", "", mention)  # remove the @ from the username
if(to_user %in% usernames)  #  save only if the mentioned user is in our data set
edges <- c(edges, from_user, to_user)
}
}
}
if(length(edges) > 0){
new_edges <- matrix(edges, ncol=2, byrow=T)
#new_nodes <- setdiff(unique(c(new_edges)), V(net)$name)
#if (length(new_nodes) > 0) {
#  net <- add_vertices(net, length(new_nodes), name=new_nodes)
#}
net3 <- add_edges(net3, t(new_edges))
}
triangles <- sum(count_triangles(net3))/3
triangles_over_time <- c(triangles_over_time, triangles)
net3 <- simplify(net3, remove.multiple = TRUE, remove.loops=T)
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
}
par(mfrow = c(1, 1))
plot(
net3,
main=paste("Rete al mese:", m),
layout=layout,
vertex.size=3,
vertex.label=NA,
edge.arrow.size=.2
)
