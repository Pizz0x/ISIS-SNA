pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(6) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- rowMeans(T_k, na.rm = TRUE)
t_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k<=4) # we group all the one with above 5 connection together
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k<=4){ # we group all the one with above 5 connection together
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 5) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(5) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>4) # we group all the one with above 5 connection together
k <- 4
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- rowMeans(T_k, na.rm = TRUE)
t_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
k_values <- as.numeric(rownames(T_matrix))
k_values <- as.numeric(colnames(T_k))
plot(k_values, t_k)
k_values <- as.numeric(rownames(T_k))
plot(k_values, t_k)
length(k_values)
k_values
k_values <- numeric(5)
k_values
k_values <- c("0", "1", "2", "3", ">4")
k_values
plot(k_values, t_k)
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k)
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k)
plot(k_values, t_k)
library(ggplot2)
ggplot( aes(x = k_values, y = t_k)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "steelblue", size = 2) +
labs(title = "Triadic Closure per Grado k",
x = "Grado k",
y = "t(k) (media)") +
theme_minimal(base_size = 13)
plot(k_values, t_k_mean, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
k_values <- c("0", "1", "2", "3", ">4")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
k_values <- c("0", "1", "2", "3", "4")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
T_k <- matrix(0, nrow = length(months)-1, ncol = 2) # when k is 5 and above in just one column
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
pairs <- numeric(2) # the number of pair that have k connection in common in the first snapshot but are not directly connected by an edge
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>1) # we group all the one with above 5 connection together
k <- 1
pairs[[k+1]] <- pairs[[k+1]] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs
}
T_k
t_k <- colMeans(T_k, na.rm = TRUE)
t_k
k_values <- c("0", "1")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
library(igraph)
library(lubridate)
T_k[,1]
T_k[,1]
T_k[,2]
T_k
T_k[1,]
T_k[,1]
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
T_k[,2]
pairs
df_tk <- data.frame( prob=c(T_k[,1], T_k[,2]), k_group = factor(c(rep("0", length(T_k_0_probs)), rep("≥1", length(T_k_1_probs)))))
df_tk <- data.frame( prob=c(T_k[,1], T_k[,2]), k_group = factor(c(rep("0", length(T_k[,1])), rep("≥1", length(T_k[,2])))))
boxplot(prob ~ k_group, data = closure_probs,
main = "Probability of Link Formation by Number of Common Neighbors",
xlab = "Common Neighbors (k)",
ylab = "Link Formation Probability",
col = c("lightgray", "lightblue"))
df_tk <- data.frame( prob=c(T_k[,1], T_k[,2]), k_group = factor(c(rep("0", length(T_k[,1])), rep("≥1", length(T_k[,2])))))
boxplot(prob ~ k_group, data = dt_tk,
main = "Probability of Link Formation by Number of Common Neighbors",
xlab = "Common Neighbors (k)",
ylab = "Link Formation Probability",
col = c("lightgray", "lightblue"))
df_tk <- data.frame( prob=c(T_k[,1], T_k[,2]), k_group = factor(c(rep("0", length(T_k[,1])), rep("≥1", length(T_k[,2])))))
boxplot(prob ~ k_group, data = df_tk,
main = "Probability of Link Formation by Number of Common Neighbors",
xlab = "Common Neighbors (k)",
ylab = "Link Formation Probability",
col = c("lightgray", "lightblue"))
T_k
t_k <- colMeans(T_k, na.rm = TRUE)
k_values <- c("0", "1")
k_values
plot(k_values, t_k, type = "b", pch = 16, col = "blue",
xlab = "Grado k", ylab = "t(k)",
main = "Triadic Closure con barre di errore")
T_k
T_k <- matrix(0, nrow = length(months)-1, ncol = 2) # when k is 5 and above in just one column
pairs <- matrix(0, nrow = length(months)-1, ncol=2)
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>1) # we group all the one with above 5 connection together
k <- 1
pairs[m,k+1] <- pairs[m,k+1] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k[m,] <- T_k[m,] / pairs[m,]
}
T_k
pairs
T_k <- matrix(0, nrow = length(months)-1, ncol = 2) # when k is 5 and above in just one column
T_k_frac <- matrix(0, nrow = length(months)-1, ncol = 2)
pairs <- matrix(0, nrow = length(months)-1, ncol=2)
for (m in 1:(length(months)-1)){
snap1 <- graph_list[[months[m]]]
snap2 <- graph_list[[months[m+1]]]
adj1 <- as_adj(snap1, sparse = FALSE)
adj2 <- as_adj(snap2, sparse=FALSE)
# first we get the common connections between each pair of nodes
com_connection <- adj1 %*% adj1 # this give us a matrix containing in each cell the number of path of length 2 between the nodes of row i and column j, so basically the number of common neighbors between node i and node j
# we now have to obtain only the pairs that haven't already formed an edge, so we are interested only in pair that aren't connected in adj1 and check if they have formed a connection in adj2, we use com_connection to know how many common connection they have so to save them into the right column
n <- nrow(adj1)
for(i in 1:(n-1)){
for(j in (i+1):n){
if(adj1[i,j]==0){  # if they don't have a connection in the first snaphshot
k <- com_connection[i,j]
if(k>1) # we group all the one with above 5 connection together
k <- 1
pairs[m,k+1] <- pairs[m,k+1] + 1
if(adj2[i,j]==1)
T_k[m, k+1] <- T_k[m, k+1] + 1 # increase the function
}
}
}
T_k_frac[m,] <- T_k[m,] / pairs[m,]
}
T_k
pairs
T_k
pairs
T_k_tot <- colSums(T_k)
pairs_tot <- colSums(pairs)
T_k_tot
pairs_tot
T_k_tot <- T_k_tot / pairs_tot
T_k_tot
barplot(T_k_tot)
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"))
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"), legend.text = c("No common neighbor", "At least 1 common neighbor"),)
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"), legend.text = c("No common neighbor", "At least 1 common neighbor"),  args.legend = list(x = "topright"),)
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"), legend.text = c("No common neighbor", "At least 1 common neighbor"),  args.legend = list(x = "bottomright"),)
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"),main = "T(k) per month",
ylab = "Number of new links")
barplot(T_k_tot, beside=T, names.arg=c("0", "≥1"),main = "T(k) per month",
ylab = "Probability of nodes connection")
barplot(T_k_tot, beside=T, names.arg=c("0 common neighbors", "≥1 common neighbors"),main = "T(k) per month",
ylab = "Probability of nodes connection")
barplot(T_k, names.arg=months[-1])
barplot(t(T_k), names.arg=months[-1])
barplot(t(T_k_frac), names.arg=months[-1])
barplot(t(T_k), names.arg=months[-1])
barplot(t(T_k), names.arg=months[-1], col=c("red", "blue"),   legend.text = c("0 common neighbor", "≥1 common neighbor"))
barplot(T_k_tot, beside=T, names.arg=c("0 common neighbors", "≥1 common neighbors"), main = "T(k) per month",
ylab = "Probability of nodes connection")
barplot(T_k_tot, beside=T, names.arg=c("0 common neighbors", "≥1 common neighbors"), main = "T(k) per month",
ylab = "Probability of nodes connection", col=c("red", "blue"))
w <- cluster_edge_betweenness(net2)
sort(table(w$membership)) # vector that associate each node with a community that represent the nodes that interact with each other mostly.
# we have 5 significant communities with 9 or more nodes, let's remake the graph with different color for each community -> graphical visualization:
V(net2)$color <- rep("white", length(w$membership))
keepTheseCommunities <- names(sizes(w))[sizes(w) > 4]
matchIndex <- match(w$membership, keepTheseCommunities) # like %in%
colorVals <- rainbow(10)[matchIndex[!is.na(matchIndex)]]
V(net2)$color[!is.na(matchIndex)] <- colorVals
plot.igraph(net2, vertex.label = NA,layout=layout, vertex.size=5)
communities <- cluster_lovain(net2)
communities <- cluster_louvain(net2)
communities
V(net2)$community <- membership(communities)
V(net2)$community
centrality_df <- data.frame(
node = V(net2)$username,
community = V(net2)$community,
degree = degree(net2),
betweenness = betweenness(net2),
closeness = closeness(net2)
)
centrality_df <- data.frame(
node = V(net2)$name,
community = V(net2)$community,
degree = degree(net2),
betweenness = betweenness(net2),
closeness = closeness(net2)
)
head(centrality_df)
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
betweenness = betweenness(net2),
closeness = closeness(net2)
)
head(centrality_df)
centrality_df
aggregate(. ~ community, data = centrality_df[, -1], FUN = mean)
aggregate(. ~ community, data = centrality_df, FUN = mean)
communities
communities <- fastgreedy.community(net2)
communities
communities <- multilevel.community(g_likes)
communities
communities <- multilevel.community(net2)
communities
V(net2)$community <- membership(communities)
V(net2)$community
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
betweenness = betweenness(net2), # how much a node control the flow of information
closeness = closeness(net2)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the newtork
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
centrality = eigen_centrality(net2),
betweenness = betweenness(net2), # how much a node control the flow of information
closeness = closeness(net2)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean)
warnings()
centrality_df
eigen_centrality(net2)
eigen_centrality(net2)$vector
betweenness(net2)
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
centrality = eigen_centrality(net2)$vector,
betweenness = betweenness(net2), # how much a node control the flow of information
closeness = closeness(net2)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the newtork
E(net2)$weight
communities <- multilevel.community(net2, weights = E(net2)$weight)
communities
V(net2)$community <- membership(communities)
V(net2)$community
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net)$weight),
centrality = eigen_centrality(net2)$vector,  # how central a community is
betweenness = betweenness(net2), # how much a node control the flow of information
closeness = closeness(net2)      # how fast a node can reach other nodes, the inverse of distances
)
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2)$vector,  # how central a community is
betweenness = betweenness(net2), # how much a node control the flow of information
closeness = closeness(net2)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean)
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weight), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weight)      # how fast a node can reach other nodes, the inverse of distances
)
inv_weights <- 1 / E(net2)$weight
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weights), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weights)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the network
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2, weights = E(net2)$weight)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weights), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weights)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the network
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2, weights = inv_weights)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weights), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weights)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the network
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2, weights = E(net2)$weight)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weights), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weights)      # how fast a node can reach other nodes, the inverse of distances
)
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the network
colorVals <- c("red", "blue", "yellow", "green", "violet", "darkgreen", "orange", "skyblue")
V(net2)$color <- colorVals[community]
colorVals <- c("red", "blue", "yellow", "green", "violet", "darkgreen", "orange", "skyblue")
centrality_df <- data.frame(
community = V(net2)$community,
degree = degree(net2),
strength = strength(net2, weights = E(net2)$weight),
centrality = eigen_centrality(net2, weights = E(net2)$weight)$vector,  # how central a community is
betweenness = betweenness(net2, weights = inv_weights), # how much a node control the flow of information
closeness = closeness(net2, weights = inv_weights),    # how fast a node can reach other nodes, the inverse of distances
color = colorVals[V(net2)$community]
)
centrality_df
aggregate(. ~ community, data = centrality_df, FUN = mean) # we check how the communities behave in the network
colorVals <- c("red", "blue", "yellow", "green", "violet", "darkgreen", "orange", "skyblue")
V(net2)$color <- colorVals[V(net2)$community]
plot.igraph(net2, vertex.label = NA,layout=layout, vertex.size=5)
